{
  "version": 3,
  "sources": ["../src/plugin/constants.ts", "../src/plugin/utils.ts", "../src/plugin/component-analyzer.ts", "../src/plugin/variable-manager.ts", "../src/plugin/storage.ts", "../src/plugin/interaction-manager.ts", "../src/plugin/main.ts"],
  "sourcesContent": ["// Constants for the State Machine Plugin\n\nexport const RESET_TO_INITIAL = 'RESET_TO_INITIAL';\nexport const DEBUG_INSTANCE_INDEX = 16; // For debugging specific instance (Instance 17)\nexport const VARIABLE_COLLECTION_NAME = 'state-machine';\nexport const STORAGE_KEY_PREFIX = 'interaction_';\n\n// UI dimensions\nexport const UI_WIDTH = 800;\nexport const UI_HEIGHT = 600; ", "// Utility functions for the State Machine Plugin\n/// <reference types=\"@figma/plugin-typings\" />\n\n/**\n * Utility function to extract string value from component property\n */\nexport function extractPropertyValue(propValue: any): string {\n  if (typeof propValue === 'string') {\n    return propValue;\n  }\n  \n  if (propValue && typeof propValue === 'object') {\n    const objValue = propValue as any;\n    if ('value' in objValue) {\n      return String(objValue.value);\n    }\n    if ('name' in objValue) {\n      return String(objValue.name);\n    }\n    return String(propValue);\n  }\n  \n  return String(propValue);\n}\n\n/**\n * Send a message to the UI\n */\nexport function sendMessageToUI(type: string, data?: any, message?: string): void {\n  figma.ui.postMessage({ type, data, message });\n}\n\n/**\n * Handle errors gracefully and send to UI\n */\nexport function handleError(error: unknown, context: string): void {\n  const message = error instanceof Error ? error.message : 'Unknown error';\n  console.error(`${context}:`, error);\n  sendMessageToUI('error', null, `${context}: ${message}`);\n} ", "// Component analysis module for detecting and analyzing component variants\n/// <reference types=\"@figma/plugin-typings\" />\n\nimport { ComponentInfo, PropertyAnalysisResult } from './types';\n\n/**\n * Find all nested component instances within a selected node\n */\nexport function findNestedInstances(node: SceneNode): InstanceNode[] {\n  const instances: InstanceNode[] = [];\n  \n  function traverse(node: SceneNode) {\n    if (node.type === 'INSTANCE') {\n      instances.push(node);\n    }\n    \n    if ('children' in node) {\n      for (const child of node.children) {\n        traverse(child);\n      }\n    }\n  }\n  \n  // Start traversal from children (exclude the main selected instance)\n  if ('children' in node) {\n    for (const child of node.children) {\n      traverse(child);\n    }\n  }\n  \n  return instances;\n}\n\n/**\n * Group component instances by their component set or individual component\n */\nexport async function groupInstancesByComponent(instances: InstanceNode[]): Promise<ComponentInfo[]> {\n  const componentMap = new Map<string, ComponentInfo>();\n  \n  for (const instance of instances) {\n    const mainComponent = await instance.getMainComponentAsync();\n    if (!mainComponent) continue;\n    \n    // Check if this component is part of a component set\n    const componentSet = mainComponent.parent;\n    let groupingId: string;\n    let groupingName: string;\n    \n    if (componentSet && componentSet.type === 'COMPONENT_SET') {\n      // Group by component set (all variants together)\n      groupingId = componentSet.id;\n      groupingName = componentSet.name;\n    } else {\n      // Fallback to individual component (non-variant components)\n      groupingId = mainComponent.id;\n      groupingName = mainComponent.name;\n    }\n    \n    if (!componentMap.has(groupingId)) {\n      componentMap.set(groupingId, {\n        id: groupingId,\n        name: groupingName,\n        instances: [],\n        states: [],\n        properties: {}\n      });\n    }\n    \n    const componentInfo = componentMap.get(groupingId)!;\n    componentInfo.instances.push(instance);\n    \n    // Extract states from component properties\n    if (instance.componentProperties && componentSet && componentSet.type === 'COMPONENT_SET') {\n      const componentSetNode = componentSet as ComponentSetNode;\n      \n      for (const [propName, _propValue] of Object.entries(instance.componentProperties)) {\n        if (!componentInfo.properties[propName]) {\n          componentInfo.properties[propName] = [];\n        }\n        \n        // Get all possible values for this property from the component set\n        if (componentSetNode.componentPropertyDefinitions) {\n          const propDef = componentSetNode.componentPropertyDefinitions[propName];\n          if (propDef && propDef.type === 'VARIANT' && propDef.variantOptions) {\n            // Add all variant options for this property\n            propDef.variantOptions.forEach(option => {\n              if (!componentInfo.properties[propName].includes(option)) {\n                componentInfo.properties[propName].push(option);\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n  \n  return Array.from(componentMap.values());\n}\n\n/**\n * Find the actual VARIANT property name for a component\n */\nexport async function findVariantProperty(\n  primaryProp: string, \n  instances: InstanceNode[]\n): Promise<PropertyAnalysisResult> {\n  if (instances.length === 0) {\n    return { actualPropertyName: null, isVariantProperty: false };\n  }\n\n  const firstInstance = instances[0];\n  const mainComponent = await firstInstance.getMainComponentAsync();\n  const componentSet = mainComponent?.parent;\n  \n  // Check the component set for VARIANT properties\n  if (componentSet && componentSet.type === 'COMPONENT_SET') {\n    const componentSetNode = componentSet as ComponentSetNode;\n    \n    if (componentSetNode.componentPropertyDefinitions) {\n      for (const [propName, propDef] of Object.entries(componentSetNode.componentPropertyDefinitions)) {\n        // Only match VARIANT type properties\n        if (propDef.type === 'VARIANT' && \n            (propName === primaryProp || propName.toLowerCase() === primaryProp.toLowerCase())) {\n          return { actualPropertyName: propName, isVariantProperty: true };\n        }\n      }\n    }\n  }\n  \n  return { actualPropertyName: null, isVariantProperty: false };\n} ", "// Variable manager module for handling Figma variables creation and management\n/// <reference types=\"@figma/plugin-typings\" />\n\nimport { ComponentInfo, Interaction, VariableBindingResult } from './types';\nimport { VARIABLE_COLLECTION_NAME } from './constants';\nimport { extractPropertyValue } from './utils';\n\nlet variableCollection: VariableCollection | null = null;\n\n/**\n * Setup variable collection for state management\n */\nexport async function setupVariableCollection(): Promise<void> {\n  try {\n    // Check if collection already exists\n    const existingCollections = await figma.variables.getLocalVariableCollectionsAsync();\n    variableCollection = existingCollections.find(c => c.name === VARIABLE_COLLECTION_NAME) || null;\n    \n    if (!variableCollection) {\n      variableCollection = figma.variables.createVariableCollection(VARIABLE_COLLECTION_NAME);\n    }\n    \n  } catch (error) {\n    console.error('Error setting up variable collection:', error);\n  }\n}\n\n/**\n * Get the current variable collection\n */\nexport function getVariableCollection(): VariableCollection | null {\n  return variableCollection;\n}\n\n/**\n * Create and bind variables for component instances\n */\nexport async function createAndBindVariables(\n  interaction: Interaction,\n  component: ComponentInfo,\n  actualPropertyName: string,\n  primaryProp: string\n): Promise<VariableBindingResult> {\n  if (!variableCollection) {\n    throw new Error('Variable collection not initialized');\n  }\n\n  const instanceVars: Variable[] = [];\n  const originalStates: string[] = [];\n  \n  for (let i = 0; i < component.instances.length; i++) {\n    const instance = component.instances[i];\n    \n    // Create a unique variable for this instance\n    const instanceVar = figma.variables.createVariable(\n      `${interaction.id}_instance_${i}_${primaryProp}`, \n      variableCollection, \n      'STRING'\n    );\n    \n    // Get and store the original state of this instance\n    let originalState = '';\n    if (instance.componentProperties && instance.componentProperties[actualPropertyName]) {\n      const propValue = instance.componentProperties[actualPropertyName];\n      originalState = extractPropertyValue(propValue);\n    }\n    \n    originalStates.push(originalState);\n    \n    // Set initial value to original state\n    instanceVar.setValueForMode(variableCollection.defaultModeId, originalState);\n    instanceVars.push(instanceVar);\n    \n    // Bind the variable to the variant property\n    try {\n      const variableAlias = figma.variables.createVariableAlias(instanceVar);\n      const properties: {[key: string]: any} = {};\n      properties[actualPropertyName] = variableAlias;\n      instance.setProperties(properties);\n    } catch (bindError) {\n      console.error(`Failed to bind variable to instance ${i + 1}:`, bindError);\n    }\n  }\n\n  return { instanceVars, originalStates };\n}\n\n/**\n * Comprehensive cleanup of orphaned variables and broken assignments\n */\nexport async function performComprehensiveCleanup(): Promise<void> {\n  try {\n    const allVariables = await figma.variables.getLocalVariablesAsync();\n    const allCollections = await figma.variables.getLocalVariableCollectionsAsync();\n    \n    // Find our state management collection\n    const stateCollection = allCollections.find(c => c.name === VARIABLE_COLLECTION_NAME);\n    \n    if (!stateCollection) {\n      return;\n    }\n    \n    // Get all variables in our collection\n    const stateVariables = allVariables.filter(v => v.variableCollectionId === stateCollection.id);\n    \n    if (stateVariables.length === 0) {\n      return;\n    }\n    \n    // Find all variables that are actually in use by collecting all variable IDs from reactions\n    const variablesInUse = new Set<string>();\n    \n    // Check all nodes in the document for reactions that use our variables\n    const allNodes = figma.currentPage.findAll();\n    for (const node of allNodes) {\n      if ('reactions' in node && node.reactions) {\n        for (const reaction of node.reactions) {\n          if (reaction.actions) {\n            for (const action of reaction.actions) {\n              if (action.type === 'SET_VARIABLE' && action.variableId) {\n                variablesInUse.add(action.variableId);\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Remove only orphaned variables (those not referenced by any reactions)\n    let removedCount = 0;\n    for (const variable of stateVariables) {\n      if (!variablesInUse.has(variable.id)) {\n        try {\n          variable.remove();\n          removedCount++;\n        } catch (error) {\n          console.error(`Failed to remove variable \"${variable.name}\":`, error);\n        }\n      }\n    }\n    \n    console.log(`Removed ${removedCount} orphaned variables`);\n    \n  } catch (error) {\n    console.error('Error during comprehensive cleanup:', error);\n  }\n}\n\n/**\n * Clean up existing variables for a specific interaction\n */\nexport async function cleanupExistingInteraction(interactionId: string): Promise<void> {\n  if (!variableCollection) return;\n  \n  try {\n    const existingVariables = await figma.variables.getLocalVariablesAsync();\n    \n    for (const variable of existingVariables) {\n      if (variable.variableCollectionId === variableCollection.id && \n          variable.name.startsWith(interactionId)) {\n        variable.remove();\n      }\n    }\n    \n  } catch (error) {\n    console.error('Error during cleanup:', error);\n  }\n}\n\n/**\n * Create variables for an interaction\n */\nexport async function createInteractionVariables(\n  interactionData: Interaction\n): Promise<{ primaryVar: Variable; conditionalVars: Variable[] }> {\n  if (!variableCollection) {\n    throw new Error('Variable collection not initialized');\n  }\n\n  const interactionId = interactionData.id;\n  const primaryVarName = `${interactionId}_primary`;\n  \n  // Create boolean variable for primary action\n  const primaryVar = figma.variables.createVariable(primaryVarName, variableCollection, 'BOOLEAN');\n  \n  // Set default value\n  primaryVar.setValueForMode(variableCollection.defaultModeId, false);\n  \n  // Create variables for conditional rules\n  const conditionalVars: Variable[] = [];\n  for (let i = 0; i < interactionData.conditionalRules.length; i++) {\n    const conditionalVarName = `${interactionId}_conditional_${i}`;\n    const conditionalVar = figma.variables.createVariable(conditionalVarName, variableCollection, 'BOOLEAN');\n    conditionalVar.setValueForMode(variableCollection.defaultModeId, false);\n    conditionalVars.push(conditionalVar);\n  }\n\n  return { primaryVar, conditionalVars };\n} ", "// Storage module for handling client storage operations\n/// <reference types=\"@figma/plugin-typings\" />\n\nimport { Interaction, ComponentInfo } from './types';\nimport { STORAGE_KEY_PREFIX } from './constants';\n\n/**\n * Store interaction data in client storage\n */\nexport async function storeInteractionData(interactionData: Interaction): Promise<void> {\n  try {\n    const storageKey = `${STORAGE_KEY_PREFIX}${interactionData.component}`;\n    await figma.clientStorage.setAsync(storageKey, JSON.stringify(interactionData));\n  } catch (error) {\n    console.error('Error storing interaction data:', error);\n  }\n}\n\n/**\n * Retrieve interaction data from client storage\n */\nexport async function retrieveInteractionData(componentId: string): Promise<Interaction | null> {\n  try {\n    const storageKey = `${STORAGE_KEY_PREFIX}${componentId}`;\n    const storedData = await figma.clientStorage.getAsync(storageKey);\n    if (storedData) {\n      const interactionData = JSON.parse(storedData);\n      return interactionData;\n    }\n  } catch (error) {\n    console.error('Error retrieving interaction data:', error);\n  }\n  return null;\n}\n\n/**\n * Clean up stored interaction data for current components\n */\nexport async function cleanupStoredInteractions(components: ComponentInfo[]): Promise<void> {\n  try {\n    for (const component of components) {\n      const storageKey = `${STORAGE_KEY_PREFIX}${component.id}`;\n      await figma.clientStorage.deleteAsync(storageKey);\n    }\n  } catch (error) {\n    console.error('Error cleaning up stored interactions:', error);\n  }\n}\n\n/**\n * Get all existing interactions for a list of components\n */\nexport async function getExistingInteractions(\n  components: ComponentInfo[]\n): Promise<{ [componentId: string]: Interaction }> {\n  const existingInteractions: { [componentId: string]: Interaction } = {};\n  \n  for (const component of components) {\n    const existingInteraction = await retrieveInteractionData(component.id);\n    if (existingInteraction) {\n      existingInteractions[component.id] = existingInteraction;\n    }\n  }\n  \n  return existingInteractions;\n} ", "// Interaction manager module for handling interaction creation and management\n/// <reference types=\"@figma/plugin-typings\" />\n\nimport { Interaction, ComponentInfo } from './types';\nimport { RESET_TO_INITIAL } from './constants';\nimport { extractPropertyValue, sendMessageToUI } from './utils';\nimport { \n  setupVariableCollection, \n  createInteractionVariables, \n  createAndBindVariables, \n  cleanupExistingInteraction \n} from './variable-manager';\nimport { findVariantProperty } from './component-analyzer';\nimport { storeInteractionData } from './storage';\n\nlet componentData: ComponentInfo[] = [];\nconst interactions: Interaction[] = [];\n\n/**\n * Set component data for interaction management\n */\nexport function setComponentData(data: ComponentInfo[]): void {\n  componentData = data;\n}\n\n/**\n * Get current component data\n */\nexport function getComponentData(): ComponentInfo[] {\n  return componentData;\n}\n\n/**\n * Create interaction and corresponding variables\n */\nexport async function createInteraction(interactionData: Interaction): Promise<void> {\n  try {\n    await setupVariableCollection();\n    \n    // Clean up any existing interaction with the same ID\n    await cleanupExistingInteraction(interactionData.id);\n    \n    // Create variables for this interaction\n    const { primaryVar, conditionalVars } = await createInteractionVariables(interactionData);\n    \n    // Store the interaction\n    interactions.push(interactionData);\n    \n    // Store interaction data in client storage for persistence\n    await storeInteractionData(interactionData);\n    \n    // Apply variables and prototype links to instances\n    await applyInteractionToInstances(interactionData, primaryVar, conditionalVars);\n    \n    const componentName = componentData.find(c => c.id === interactionData.component)?.name || 'Unknown Component';\n    sendMessageToUI('interaction-created', null, `Interaction created successfully for ${componentName}`);\n    \n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    sendMessageToUI('error', null, `Failed to create interaction: ${message}`);\n  }\n}\n\n/**\n * Apply interaction to component instances\n */\nasync function applyInteractionToInstances(\n  interaction: Interaction, \n  _primaryVar: Variable, \n  _conditionalVars: Variable[]\n): Promise<void> {\n  try {\n    // Find the component\n    const component = componentData.find(c => c.id === interaction.component);\n    if (!component) return;\n    \n    // Parse the primary action to get property and value  \n    const [primaryProp, primaryValue] = interaction.primaryAction.split('=');\n    \n    // Find the actual VARIANT property name for the component\n    const { actualPropertyName, isVariantProperty } = await findVariantProperty(primaryProp, component.instances);\n    \n    // Create and bind variables for this interaction (only if we have a valid variant property)\n    let instanceVars: Variable[] = [];\n    let originalStates: string[] = [];\n    \n    if (actualPropertyName && isVariantProperty) {\n      const result = await createAndBindVariables(interaction, component, actualPropertyName, primaryProp);\n      instanceVars = result.instanceVars;\n      originalStates = result.originalStates;\n    }\n    \n    // Clean up existing reactions on all instances first\n    for (let i = 0; i < component.instances.length; i++) {\n      const instance = component.instances[i];\n      try {\n        await instance.setReactionsAsync([]);\n      } catch (error) {\n        console.error(`Failed to clear reactions on instance ${i + 1}:`, error);\n      }\n    }\n    \n    // Apply reactions to each instance\n    for (let i = 0; i < component.instances.length; i++) {\n      const instance = component.instances[i];\n      \n      try {\n        if (actualPropertyName && isVariantProperty && instanceVars.length > 0) {\n          await applyVariableBasedReactions(\n            instance, \n            i, \n            interaction, \n            component, \n            instanceVars, \n            originalStates, \n            primaryProp, \n            primaryValue\n          );\n        } else {\n          // Create basic click interaction without state management\n          const reaction = {\n            trigger: { type: 'ON_CLICK' as const },\n            actions: []\n          };\n          \n          await instance.setReactionsAsync([reaction]);\n        }\n        \n      } catch (reactionError) {\n        console.error(`Failed to apply reaction to ${instance.name}:`, reactionError);\n      }\n    }\n    \n  } catch (error) {\n    console.error('Error applying interaction to instances:', error);\n  }\n}\n\n/**\n * Apply variable-based reactions to an instance\n */\nasync function applyVariableBasedReactions(\n  instance: InstanceNode,\n  instanceIndex: number,\n  interaction: Interaction,\n  component: ComponentInfo,\n  instanceVars: Variable[],\n  originalStates: string[],\n  primaryProp: string,\n  primaryValue: string\n): Promise<void> {\n  // Create variable-based actions for state management\n  const actions = [\n    // Action 1: Set this instance to primary action value\n    {\n      type: 'SET_VARIABLE' as const,\n      variableId: instanceVars[instanceIndex].id,\n      variableValue: {\n        resolvedType: 'STRING' as const,\n        type: 'STRING' as const,\n        value: String(primaryValue)\n      }\n    }\n  ];\n  \n  // Action 2: Process conditional rules for other instances\n  const ruleMap = new Map<string, string>();\n  let mainResetValue: string | null = null;\n  \n  for (const rule of interaction.conditionalRules) {\n    if (!rule.condition || !rule.action || !rule.condition.includes('=')) {\n      continue;\n    }\n    \n    const [conditionProp, conditionValue] = rule.condition.split('=');\n    const actionValue = rule.action;\n    \n    if ((conditionProp === primaryProp || conditionProp.toLowerCase() === primaryProp.toLowerCase())) {\n      ruleMap.set(conditionValue, actionValue);\n      \n      if (conditionValue === primaryValue) {\n        mainResetValue = actionValue;\n      }\n    }\n  }\n  \n  // Apply rules to other instances\n  for (let j = 0; j < component.instances.length; j++) {\n    if (instanceIndex === j) continue; // Skip the clicked instance\n    \n    const otherInstance = component.instances[j];\n    \n    // Get current value of other instance\n    let currentInstanceValue = '';\n    if (otherInstance.componentProperties && otherInstance.componentProperties[primaryProp]) {\n      const propValue = otherInstance.componentProperties[primaryProp];\n      currentInstanceValue = extractPropertyValue(propValue);\n    }\n    \n    // Determine target value based on rules\n    let targetValue: string = originalStates[j]; // Default to original state\n    let ruleApplied = false;\n    \n    // Check if there's a specific rule for this instance's current state\n    if (ruleMap.has(currentInstanceValue)) {\n      const ruleAction = ruleMap.get(currentInstanceValue)!;\n      \n      if (ruleAction === RESET_TO_INITIAL) {\n        targetValue = originalStates[j];\n        ruleApplied = true;\n      } else if (ruleAction.includes('=')) {\n        const [actionProp, actionValue] = ruleAction.split('=');\n        if (actionProp === primaryProp || actionProp.toLowerCase() === primaryProp.toLowerCase()) {\n          targetValue = actionValue;\n          ruleApplied = true;\n        }\n      }\n    } \n    \n    // If no specific rule matched, check if there's a main reset rule\n    if (!ruleApplied && mainResetValue) {\n      if (mainResetValue === RESET_TO_INITIAL) {\n        targetValue = originalStates[j];\n        ruleApplied = true;\n      } else if (mainResetValue.includes('=')) {\n        const [actionProp, actionValue] = mainResetValue.split('=');\n        if (actionProp === primaryProp || actionProp.toLowerCase() === primaryProp.toLowerCase()) {\n          targetValue = actionValue;\n          ruleApplied = true;\n        }\n      }\n    }\n    \n    // Final fallback: reset to original state\n    if (!ruleApplied) {\n      targetValue = originalStates[j];\n    }\n    \n    actions.push({\n      type: 'SET_VARIABLE' as const,\n      variableId: instanceVars[j].id,\n      variableValue: {\n        resolvedType: 'STRING' as const,\n        type: 'STRING' as const,\n        value: String(targetValue)\n      }\n    });\n  }\n  \n  // Create the reaction for this instance\n  const reaction = {\n    trigger: { type: 'ON_CLICK' as const },\n    actions: actions\n  };\n  \n  // Apply the reaction to this instance\n  await instance.setReactionsAsync([reaction]);\n} ", "// Main plugin entry point for the State Machine Plugin\n/// <reference types=\"@figma/plugin-typings\" />\n\nimport { UI_WIDTH, UI_HEIGHT } from './constants';\nimport { sendMessageToUI, handleError } from './utils';\nimport { InitSuccessData } from './types';\nimport { findNestedInstances, groupInstancesByComponent } from './component-analyzer';\nimport { setupVariableCollection, performComprehensiveCleanup } from './variable-manager';\nimport { createInteraction, setComponentData, getComponentData } from './interaction-manager';\nimport { getExistingInteractions, cleanupStoredInteractions } from './storage';\n\n// Initialize plugin\nfigma.showUI(__html__, { width: UI_WIDTH, height: UI_HEIGHT });\n\n// Add selection change listener to automatically update UI\nfigma.on('selectionchange', async () => {\n  // Show loading state in UI\n  sendMessageToUI('selection-changed', null, 'Analyzing new selection...');\n  await initializePlugin();\n});\n\n// Main message handler\nfigma.ui.onmessage = async (msg: { type: string; data?: any }) => {\n  try {\n    switch (msg.type) {\n      case 'init':\n        await initializePlugin();\n        break;\n      case 'create-interaction':\n        await createInteraction(msg.data);\n        break;\n      case 'get-components':\n        sendMessageToUI('components-data', getComponentData());\n        break;\n      case 'cleanup':\n        await performComprehensiveCleanup();\n        sendMessageToUI('cleanup-complete', null, 'Comprehensive cleanup completed successfully');\n        break;\n      case 'cleanup-stored-data':\n        await cleanupStoredInteractions(getComponentData());\n        sendMessageToUI('cleanup-complete', null, 'Stored interaction data cleaned up successfully');\n        break;\n      case 'cancel':\n        figma.closePlugin();\n        break;\n      default:\n        console.log('Unknown message type:', msg.type);\n    }\n  } catch (error) {\n    handleError(error, 'Message handler');\n  }\n};\n\n/**\n * Initialize plugin and analyze selection\n */\nasync function initializePlugin(): Promise<void> {\n  try {\n    const selection = figma.currentPage.selection;\n    \n    // Validate selection\n    if (selection.length !== 1) {\n      sendMessageToUI('error', null, 'Please select exactly one component instance.');\n      return;\n    }\n\n    const selectedNode = selection[0];\n    \n    // Check if selected node is a component instance\n    if (selectedNode.type !== 'INSTANCE') {\n      sendMessageToUI('error', null, 'Selected element must be a component instance.');\n      return;\n    }\n\n    // Analyze nested instances\n    const nestedInstances = findNestedInstances(selectedNode);\n    \n    if (nestedInstances.length === 0) {\n      sendMessageToUI('error', null, 'No nested component instances found in selection.');\n      return;\n    }\n\n    // Group instances by component\n    const componentData = await groupInstancesByComponent(nestedInstances);\n    \n    // Set component data for other modules\n    setComponentData(componentData);\n    \n    // Create or get variable collection\n    await setupVariableCollection();\n    \n    // Check for existing interactions for each component\n    const existingInteractions = await getExistingInteractions(componentData);\n    \n    // Send success message with component data and existing interactions\n    const initData: InitSuccessData = {\n      selectedInstance: selectedNode.name,\n      components: componentData,\n      existingInteractions: existingInteractions\n    };\n    \n    sendMessageToUI('init-success', initData);\n    \n  } catch (error) {\n    handleError(error, 'Initialization failed');\n  }\n} "],
  "mappings": "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",
  "names": ["RESET_TO_INITIAL", "VARIABLE_COLLECTION_NAME", "STORAGE_KEY_PREFIX", "extractPropertyValue", "propValue", "objValue", "sendMessageToUI", "type", "data", "message", "handleError", "error", "context", "findNestedInstances", "node", "instances", "traverse", "child", "groupInstancesByComponent", "componentMap", "instance", "mainComponent", "componentSet", "groupingId", "groupingName", "componentInfo", "componentSetNode", "propName", "_propValue", "propDef", "option", "findVariantProperty", "primaryProp", "variableCollection", "setupVariableCollection", "c", "VARIABLE_COLLECTION_NAME", "error", "createAndBindVariables", "interaction", "component", "actualPropertyName", "primaryProp", "variableCollection", "instanceVars", "originalStates", "i", "instance", "instanceVar", "originalState", "propValue", "extractPropertyValue", "variableAlias", "properties", "bindError", "performComprehensiveCleanup", "allVariables", "stateCollection", "c", "VARIABLE_COLLECTION_NAME", "stateVariables", "v", "variablesInUse", "allNodes", "node", "reaction", "action", "removedCount", "variable", "error", "cleanupExistingInteraction", "interactionId", "existingVariables", "createInteractionVariables", "interactionData", "primaryVarName", "primaryVar", "conditionalVars", "conditionalVarName", "conditionalVar", "storeInteractionData", "interactionData", "storageKey", "STORAGE_KEY_PREFIX", "error", "retrieveInteractionData", "componentId", "storedData", "cleanupStoredInteractions", "components", "component", "getExistingInteractions", "existingInteractions", "existingInteraction", "componentData", "interactions", "setComponentData", "data", "getComponentData", "createInteraction", "interactionData", "_a", "setupVariableCollection", "cleanupExistingInteraction", "primaryVar", "conditionalVars", "createInteractionVariables", "storeInteractionData", "applyInteractionToInstances", "componentName", "c", "sendMessageToUI", "error", "message", "interaction", "_primaryVar", "_conditionalVars", "component", "primaryProp", "primaryValue", "actualPropertyName", "isVariantProperty", "findVariantProperty", "instanceVars", "originalStates", "result", "createAndBindVariables", "i", "instance", "applyVariableBasedReactions", "reaction", "reactionError", "instanceIndex", "actions", "ruleMap", "mainResetValue", "rule", "conditionProp", "conditionValue", "actionValue", "j", "otherInstance", "currentInstanceValue", "propValue", "extractPropertyValue", "targetValue", "ruleApplied", "ruleAction", "RESET_TO_INITIAL", "actionProp", "sendMessageToUI", "initializePlugin", "msg", "createInteraction", "getComponentData", "performComprehensiveCleanup", "cleanupStoredInteractions", "error", "handleError", "selection", "selectedNode", "nestedInstances", "findNestedInstances", "componentData", "groupInstancesByComponent", "setComponentData", "setupVariableCollection", "existingInteractions", "getExistingInteractions", "initData"]
}
